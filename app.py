# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Uelu2oKHiDK4cOVM1sYr4Ko7hl2SH7FW
"""

# -*- coding: utf-8 -*-
import streamlit as st
import tensorflow as tf
import numpy as np
import cv2
import os
import matplotlib.pyplot as plt

# ============================================================
# 0Ô∏è‚É£ Paths (directly from repo root)
# ============================================================
MODEL_PATH = "model.h5"
CASCADE_PATH = "indian_license_plate.xml"

# ============================================================
# 1Ô∏è‚É£ Load trained model
# ============================================================
@st.cache_resource
def load_model_cached():
    if not os.path.exists(MODEL_PATH):
        st.error(f"‚ùå Model not found at {MODEL_PATH}")
        return None
    model = tf.keras.models.load_model(MODEL_PATH, compile=False)
    return model

model = load_model_cached()

# ============================================================
# 2Ô∏è‚É£ Utility function to fix dimensions
# ============================================================
def fix_dimension(img):
    return np.stack([img]*3, axis=-1)

# ============================================================
# 3Ô∏è‚É£ Load Haar Cascade
# ============================================================
if not os.path.exists(CASCADE_PATH):
    st.error(f"‚ùå Cascade XML not found at {CASCADE_PATH}")
plate_cascade = cv2.CascadeClassifier(CASCADE_PATH)

# ============================================================
# 4Ô∏è‚É£ Detect license plate (with rectangle)
# ============================================================
def detect_plate(img, text=''):
    plate_img = img.copy()
    roi = img.copy()
    plate_rect = plate_cascade.detectMultiScale(plate_img, scaleFactor=1.2, minNeighbors=7)

    plate = None
    for (x, y, w, h) in plate_rect:
        pad = 3  # slightly smaller rectangle
        x1 = max(x - pad, 0)
        y1 = max(y - pad, 0)
        x2 = min(x + w + pad, img.shape[1])
        y2 = min(y + h + pad, img.shape[0])
        plate = roi[y1:y2, x1:x2, :]
        cv2.rectangle(plate_img, (x1, y1), (x2, y2), (51, 181, 155), 2)
        if text != '':
            cv2.putText(plate_img, text, (x1, y1-5),
                        cv2.FONT_HERSHEY_COMPLEX_SMALL, 0.7, (51,181,155), 1, cv2.LINE_AA)
    return plate_img, plate

# ============================================================
# 5Ô∏è‚É£ Find contours for character segmentation
# ============================================================
def find_contours(dimensions, img):
    cntrs, _ = cv2.findContours(img.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    lower_width, upper_width, lower_height, upper_height = dimensions
    cntrs = sorted(cntrs, key=cv2.contourArea, reverse=True)[:15]

    img_copy = img.copy()
    x_cntr_list, img_res = [], []

    for cntr in cntrs:
        intX, intY, intWidth, intHeight = cv2.boundingRect(cntr)
        if lower_width < intWidth < upper_width and lower_height < intHeight < upper_height:
            x_cntr_list.append(intX)
            char_copy = np.zeros((44, 24))
            char = img[intY:intY+intHeight, intX:intX+intWidth]
            char = cv2.resize(char, (20, 40))
            char = cv2.subtract(255, char)
            char_copy[2:42, 2:22] = char
            img_res.append(char_copy)
            cv2.rectangle(img_copy, (intX, intY), (intX+intWidth, intY+intHeight), (50, 21, 200), 1)

    plt.figure(figsize=(10,4))
    plt.imshow(img_copy, cmap='gray')
    plt.axis('off')
    plt.title("Contours on License Plate")
    plt.show()

    indices = sorted(range(len(x_cntr_list)), key=lambda k: x_cntr_list[k])
    return np.array([img_res[i] for i in indices])

# ============================================================
# 6Ô∏è‚É£ Segment characters from license plate
# ============================================================
def segment_characters(image):
    img_lp = cv2.resize(image, (333, 75))
    img_gray_lp = cv2.cvtColor(img_lp, cv2.COLOR_BGR2GRAY)
    _, img_binary_lp = cv2.threshold(img_gray_lp, 200, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

    kernel = np.ones((3,3), np.uint8)
    img_binary_lp = cv2.erode(img_binary_lp, kernel)
    img_binary_lp = cv2.dilate(img_binary_lp, kernel)

    img_binary_lp[0:3,:] = 255
    img_binary_lp[:,0:3] = 255
    img_binary_lp[72:75,:] = 255
    img_binary_lp[:,330:333] = 255

    LP_WIDTH, LP_HEIGHT = img_binary_lp.shape
    dimensions = [LP_WIDTH/6, LP_WIDTH/2, LP_HEIGHT/10, 2*LP_HEIGHT/3]

    plt.figure(figsize=(10,4))
    plt.imshow(img_binary_lp, cmap='gray')
    plt.axis('off')
    plt.title("Processed Binary Plate")
    plt.show()

    return find_contours(dimensions, img_binary_lp)

# ============================================================
# 7Ô∏è‚É£ Predict characters
# ============================================================
def predict_license_number(char_images):
    if model is None:
        return "Model not loaded"
    characters = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    dic = {i: c for i, c in enumerate(characters)}
    output = []
    for ch in char_images:
        img_resized = cv2.resize(ch, (28, 28), interpolation=cv2.INTER_AREA)
        img_rgb = fix_dimension(img_resized) / 255.0
        y_pred = model.predict(np.expand_dims(img_rgb, axis=0), verbose=0)
        output.append(dic[np.argmax(y_pred, axis=1)[0]])
    return ''.join(output)

# ============================================================
# 8Ô∏è‚É£ Display helper
# ============================================================
def display_image(img_, title=''):
    img_rgb = cv2.cvtColor(img_, cv2.COLOR_BGR2RGB)
    plt.figure(figsize=(10,6))
    plt.imshow(img_rgb)
    plt.axis('off')
    plt.title(title)
    st.pyplot(plt.gcf())

# ============================================================
# 9Ô∏è‚É£ Streamlit UI
# ============================================================
st.title("üöó License Plate Recognition")

uploaded_file = st.file_uploader(
    "Upload a license plate image", 
    type=["jpg", "jpeg", "png", "webp"]
)

if uploaded_file:
    file_bytes = np.asarray(bytearray(uploaded_file.read()), dtype=np.uint8)
    img = cv2.imdecode(file_bytes, 1)
    display_image(img, "Uploaded Image")

    detected_img, plate = detect_plate(img)
    display_image(detected_img, "Detected License Plate Region")

    if plate is not None:
        char_images = segment_characters(plate)
        if len(char_images) > 0:
            plate_number = predict_license_number(char_images)
            st.markdown(f"### üî¢ Predicted License Plate: **{plate_number}**")

            st.write("Segmented Characters:")
            plt.figure(figsize=(12,2))
            for i, c in enumerate(char_images):
                plt.subplot(1, len(char_images), i+1)
                plt.imshow(c, cmap='gray')
                plt.axis('off')
            st.pyplot(plt.gcf())
        else:
            st.warning("‚ö†Ô∏è No characters detected in the plate.")
    else:
        st.warning("‚ö†Ô∏è Could not detect license plate region.")
